use interface::i_window::IWindow;
use interface::i_game_logic::IGameLogic;
use interface::i_renderer::IRenderer;
use interface::i_ele;

pub trait KernelImplHooks < G, R, W, EInput, ERender >
    where G: IGameLogic< EventInput = EInput, EventRender = ERender >,
          R: IRenderer< EventRender = ERender >,
          W: IWindow< EventType = EInput >
{
    fn init() -> Self;
    fn init_hooks( & mut self, & mut W, & mut G, & mut Vec< R > ) -> Result< (), & 'static str >;
}

pub struct Kernel < G, R, W, EInput, ERender, H >
    where G: IGameLogic< EventInput = EInput, EventRender = ERender >,
          R: IRenderer< EventRender = ERender >,
          W: IWindow< EventType = EInput >,
          H: KernelImplHooks< G, R, W, EInput, ERender >,
{   
    pub _windowing: W,
    pub _game_logic: G,
    pub _renderer: Vec< R >, //alternative rendering pipelines
    pub _render_sigs: Vec< Box< i_ele::Ele > >, //data and commands to be sent to renderer
    pub _kernel_hooks: H,

    // _textures: Vec< texture::Texture >, //could move this to a permanent cache for long term data storage
    // pub._lights: Vec< light::LightAdsPoint >, //could move this to be generated by game logic or within a connecting adaptor between game logic and render interface
    // pub._cameras: Vec< camera::Cam >, //could move this to be generated by game logic or within a permanant cache for long term data storage
}

impl < G, R, W, EInput, ERender, H > Kernel < G, R, W, EInput, ERender, H >
    where G: IGameLogic< EventInput = EInput, EventRender = ERender >,
          R: IRenderer< EventRender = ERender >,
          W: IWindow< EventType = EInput >,
          H: KernelImplHooks< G, R, W, EInput, ERender >,
{
    pub fn init() -> Result< Self, & 'static str > {

        info!("kernel init." );

        let mut k = Kernel {
            _windowing: IWindow::init( 500, 500 ),
            _game_logic: G::init(),
            _renderer: vec![],
            _render_sigs: vec![],
            _kernel_hooks: H::init(),
            // _textures: Vec< texture::Texture >,
            // _lights: Vec< light::LightAdsPoint >,
            // _cameras: Vec< camera::Cam >,
        };
        
        k._kernel_hooks.init_hooks( & mut k._windowing, & mut k._game_logic, & mut k._renderer )?;
        
        Ok( k )
    }
    pub fn run( & mut self ) -> Result< (), & 'static str > {

        info!( "kernel running." );
        
        //foever loop and process results until exit conditions are caught
        let mut running = true;
        
        // let mut _new_win_dim = Some( ( 500, 500 ) );

        #[allow(unused_mut)]
        let mut sigs_for_window = vec![];

        while running {

            //process windowing events into buffer
            self._windowing.make_current()?;

            self._windowing.per_frame_setup()?;
            
            self._windowing.handle_signal_request( sigs_for_window.as_slice() )?;
            
            let mut events_window : Vec< EInput > = vec![];
            match self._windowing.handle_events_pass_thru() {
                Some( x ) => {
                    events_window.push( x );
                },
                _ => {},
            }
            
            // //process game logic
            //todo: put this in a parallel thread
            let ( events_render, signal_exit ) : ( Vec< ERender >, bool ) = self._game_logic.process_input_events( & events_window[..] );

            //todo: detect exit condition
            if signal_exit {
                running = false;
            }
            
            //process rendering
            //todo: put this in a parallel thread
            for i in self._renderer.iter_mut(){
                i.process_render_events( & events_render[..] ).is_ok();
            }

            self._windowing.swap_buf();
        }

        info!( "kernel shutdown." );

        Ok( () )
    }
}

