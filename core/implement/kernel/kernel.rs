// extern crate glutin;

use interface::i_window::IWindow;
use interface::i_game_logic::IGameLogic;
use interface::i_renderer::IRenderer;
use interface::i_ele;

// use implement::window::winglutin::WinGlutin;


pub struct Kernel < G, R, W, EInput, ERender >
    where G: IGameLogic< EventInput = EInput, EventRender = ERender >,
          R: IRenderer< EventRender = ERender >,
          W: IWindow< EventType = EInput >
{   
    pub _windowing: W,
    pub _game_logic: G,
    pub _renderer: Vec< R >, //alternative rendering pipelines
    pub _render_sigs: Vec< Box< i_ele::Ele > >, //data and commands to be sent to renderer

    
    // _textures: Vec< texture::Texture >, //could move this to a permanent cache for long term data storage
    // _lights: Vec< light::LightAdsPoint >, //could move this to be generated by game logic or within a connecting adaptor between game logic and render interface
    // _cameras: Vec< camera::Cam >, //could move this to be generated by game logic or within a permanant cache for long term data storage
}

impl < G, R, W, EInput, ERender > Kernel < G, R, W, EInput, ERender >
    where G: IGameLogic< EventInput = EInput, EventRender = ERender >,
          R: IRenderer< EventRender = ERender >,
          W: IWindow< EventType = EInput >
{
    pub fn init() -> Result< Self, & 'static str > {
        let k = Kernel {
            _windowing: IWindow::init( 500, 500 ),
            _game_logic: G::init(),
            _renderer: vec![],
            _render_sigs: vec![],
            // _textures: Vec< texture::Texture >,
            // _lights: Vec< light::LightAdsPoint >,
            // _cameras: Vec< camera::Cam >,
        };
        Ok( k )
    }
    pub fn run( & mut self ) -> Result< (), & 'static str > {
        //foever loop and process results until exit conditions are caught
        let mut running = true;

        let mut sig_window_close = false;
        
        let mut new_win_dim = Some( ( 500, 500 ) );
        
        let mut sigs_for_window = vec![];

        while running {

            //process windowing events into buffer
            // self._windowing.make_current();

            self._windowing.handle_signal_request( sigs_for_window.as_slice() );
            
            let mut events_window : Vec< EInput > = vec![];
            match self._windowing.handle_events_pass_thru() {
                Some( x ) => {
                    events_window.push( x );
                },
                _ => {},
            }
            
            // //process game logic
            //todo: put this in a parallel thread
            let events_render: Vec< ERender > = self._game_logic.process_input_events( & events_window[..] );

            //detect exit condition
            
            //process rendering
            //todo: put this in a parallel thread
            for i in self._renderer.iter(){
                i.process_render_events( & events_render[..] ).is_ok();
            }

            println!( "kernel running.." );

        }
        Ok( () )
    }
}

